<html>
<head>
<style>
    body {
        font-family: Calibri, sans-serif;
        margin: 3em;
        color: #444;
    }
    code {
        font-family: Consolas, monospace;
    }
    legend {
        text-align: left;
    }
    label {
        display: inline-block;
        width: 8em;
        height: 1.6em;
        text-align: right;
    }
    fieldset {
        border-radius: 4px;
        border: 2px solid #CCC;
        margin: 1em 0em;
    }
    li {
        margin: 0.5em 1.0em;
    }
    p.note {
        color: #CCC;
        margin-bottom: 0em;
        text-align: center;
    }
    div.grid {
        display: table;
    }
    div.row {
        display: table-row;
    }
    div.cell {
        display: table-cell;
        padding: 0 1em;
        vertical-align: top;
    }
    #dropFile {
        display: inline-block;
        background: #EFE;
        color: #8A8;
        border: 2px solid #8A8;
        border-radius: 4px;
        text-align: center;
        padding: 2em 4em;
        margin-bottom: 1em;
    }
    .center {
        margin: 0 auto;
    }
</style>
<script>

function jsobj(obj) {

    var name  = document.getElementById("nameText").value;
    var flat  = document.getElementById("flatArrayOption").checked;
    var typed = document.getElementById("typedArrayOption").checked;

    var v  = [];  // vertex position array
    var vi =  1;  // vertex position index

    var t  = [];  // vertex texture coordinate array
    var ti =  1;  // vertex texture coordinate index

    var n  = [];  // vertex normal array
    var ni =  1;  // vertex normal index

    var m  = {};  // vertex triplet map
    var mc =  0;  // vertex triplet index

    var model = {
        positions : [],
        texCoords : [],
        normals   : [],
        tangents  : [],
        triangles : [],
    };

    // This stringify function is used in lieu of JSON.stringify in order to
    // take control over linebreaks in the short arrays representing vectors.

    function stringify() {
        var string = "";

        function toValue(f) {
            return f.toFixed(3);
        }

        function toIndex(d) {
            return d.toString();
        }

        function stringifyTable(name, type, a, f) {
            if (a.length > 0) {

                if (typed)
                    string += '\t' + name + ' : ' + type + '([\n';
                else
                    string += '\t' + name + ' : [\n';

                for (var i = 0; i < a.length; i++)
                    if (flat)
                        string += '\t\t'   + a[i].map(f).join(', ') +   ',\n';
                    else
                        string += '\t\t[ ' + a[i].map(f).join(', ') + ' ],\n';

                if (typed)
                    string += '\t]),\n';
                else
                    string += '\t],\n';
            }
        }

        string += 'var ' + name + ' = {\n';

        stringifyTable('positions', 'Float32Array', model.positions, toValue);
        stringifyTable('texCoords', 'Float32Array', model.texCoords, toValue);
        stringifyTable('normals',   'Float32Array', model.normals,   toValue);
        stringifyTable('tangents',  'Float32Array', model.tangents,  toValue);
        stringifyTable('triangles', 'Uint16Array',  model.triangles, toIndex);

        string += '}\n';

        return string;
    }

    // Use normals and texture coordinates to calculate tangent vectors.

    function calcTangents() {

        // Return the sum of the given vectors.

        function add(x, y) {
            return [x[0] + y[0], x[1] + y[1], x[2] + y[2]];
        }

        // Return the difference of the given vectors.

        function subtract(x, y) {
            return [x[0] - y[0], x[1] - y[1], x[2] - y[2]];
        }

        // Return the cross product of the given vectors.

        function cross(x, y) {
            return [x[1] * y[2] - x[2] * y[1],
                    x[2] * y[0] - x[0] * y[2],
                    x[0] * y[1] - x[1] * y[0]];
        }

        // Return the normalization of the given vector.

        function normalize(v) {
            var k = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / k, v[1] / k, v[2] / k];
        }

        // Return vector v made orthogonal to vector u.

        function orthogonalize(u, v) {
            return cross(cross(u, v), u);
        }

        // Compute tangent vectors for all vertices...

        for (var i = 0; i < model.triangles.length; i++) {
            var j = model.triangles[i];

            // Calculate the vector tangent to triangle i.

            var dp1 = subtract(model.positions[j[1]], model.positions[j[0]]);
            var dp2 = subtract(model.positions[j[2]], model.positions[j[0]]);

            var dt1 = model.texCoords[j[1]][1] - model.texCoords[j[0]][1];
            var dt2 = model.texCoords[j[2]][1] - model.texCoords[j[0]][1];

            var t = normalize([dt2 * dp1[0] - dt1 * dp2[0],
                               dt2 * dp1[1] - dt1 * dp2[1],
                               dt2 * dp1[2] - dt1 * dp2[2]]);

            // Accumulate the tangent vector at all adjacent vertices.

            model.tangents[j[0]] = add(model.tangents[j[0]], t);
            model.tangents[j[1]] = add(model.tangents[j[1]], t);
            model.tangents[j[2]] = add(model.tangents[j[2]], t);
        }

        // Orthonormalize all tangent space bases.

        for (var i = 0; i < model.tangents.length; i++) {
            model.tangents[i] = normalize(orthogonalize(model.normals[i],
                                                        model.tangents[i]));
        }
    }

    // Return a vertex index for the given triplet string.

    function findIndex(f) {
        if (m[f] == undefined) {
            m[f] = model.positions.length;

            var a;
            var i;
            var j;
            var k;

            if ((a = /(\d+)\/(\d+)\/(\d+)/.exec(f))) {
                i = parseInt(a[1]);
                j = parseInt(a[2]);
                k = parseInt(a[3]);
            }
            if ((a = /(\d+)\/\/(\d+)/.exec(f))) {
                i = parseInt(a[1]);
                k = parseInt(a[2]);
            }
            if ((a = /(\d+)\/(\d+)/.exec(f))) {
                i = parseInt(a[1]);
                j = parseInt(a[2]);
            }
            if ((a = /(\d+)/.exec(f))) {
                i = parseInt(a[1]);
            }

            if (i)      model.positions.push(v[i > 0 ? i : i + vi]);
            if (j)      model.texCoords.push(t[j > 0 ? j : j + ti]);
            if (k)      model.normals  .push(n[k > 0 ? k : k + ni]);
            if (j && k) model.tangents .push([0, 0, 0]);
        }
        return m[f];
    }

    // Create a new triangle for the given set of triplet strings.

    function newTriangle(a, b, c) {
        ai = findIndex(a);
        bi = findIndex(b);
        ci = findIndex(c);

        model.triangles.push([ai, bi, ci]);
    }

    var line = obj.split('\n');

    for (var i = 0; i < line.length; i++) {
        token = line[i].trim().split(/\s+/);

        if (token[0] == 'v') {
            v[vi++] = [parseFloat(token[1]),
                       parseFloat(token[2]),
                       parseFloat(token[3])];
        }
        if (token[0] == 'vt') {
            t[ti++] = [parseFloat(token[1]),
                       parseFloat(token[2])];
        }
        if (token[0] == 'vn') {
            n[ni++] = [parseFloat(token[1]),
                       parseFloat(token[2]),
                       parseFloat(token[3])];
        }
        if (token[0] == 'f') {
            for (var j = 2; j < token.length - 1; j++) {
                newTriangle(token[1], token[j], token[j + 1]);
            }
        }
    }

    if (model.normals.length && model.texCoords.length)
        calcTangents();

    var url = 'data:text/json;charset=utf8,' + encodeURIComponent(stringify());

    window.open(url, '_blank');
    window.focus();
}

window.onload = function() {

    function readFiles(files) {
        for (var i = 0; i < files.length; i++) {
            var reader = new FileReader();

            reader.onload = function (e) {
                console.log(files);
                jsobj(e.target.result);
            }

            reader.readAsText(files[i]);
        }
    }

    function handleSelect(e) {
        readFiles(e.target.files);
    }

    function handleDragOver(e) {
        e.stopPropagation();
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
    }

    function handleDrop(e) {
        e.stopPropagation();
        e.preventDefault();
        readFiles(e.dataTransfer.files);
    }

    var select = document.getElementById("selectFile");
    select.addEventListener('change', handleSelect, false);

    var drop = document.getElementById("dropFile");
    drop.addEventListener('dragover', handleDragOver, false);
    drop.addEventListener('drop',     handleDrop,     false);
}

</script>
</head>
<body>
<h1>OBJ to JSON 3D Model Converter</h1>

<p>Drop or select an OBJ model. A JSON representation will open in a new tab.</p>

<form>
    <fieldset>
        <legend>Input</legend>
        <div class="grid center">
            <div class="row">
                <div class="cell">
                    <label>Object Name:</label>
                    <input id="nameText" type="text" value="obj">
                    <br>
                    <label>Flat Arrays:</label>
                    <input id="flatArrayOption" type="checkbox">
                    <br>
                    <label>Typed Arrays:</label>
                    <input id="typedArrayOption" type="checkbox">
                </div>
                <div class="cell">
                    <span id="dropFile">Drop OBJ here</span><br>
                    or <input type="file" id="selectFile" multiple>
                </div>
            </div>
        </div>
        <p class="note">This process runs in your browser and does not upload data to any server.</p>
    </fieldset>
    <fieldset>
        <legend>Documentation</legend>
        <ul>
            <li>JSON output defines a single JavaScript object with the given name.</li>
            <li>The output includes vertex attributes in <code>positions</code>, <code>normals</code>, and <code>texCoords</code> arrays, if given by the input OBJ.</li>
            <li>The output includes primitive elements in a <code>triangles</code> array.</li>
            <li>The array outputs are flat (versus nested) or TypedArray (versus Array) as configured.</li>
            <li>Material properties are ignored.</li>
            <li>Smoothing groups are ignored and objects are expected to define their own vertex normals as needed.</li>
        </ul>
    </fieldset>
    <p style="text-align:right">Copyright &copy; 2015 <a href="http://kooima.net">Robert Kooima</a></p>
</form>
</body>
</html>
